---
tags:
  - Программирование
  - Java
  - Java-OOP
  - review
sr-due: 2025-10-19
sr-interval: 9
sr-ease: 178
---
**ООП** - это методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса.

## Зачем нужно?

- **Проблема:** Сложность управления большими процедурными программами.
- **Преимущества:**
    - Управление сложностью через декомпозицию
    - Повторное использование кода
    - Упрощение сопровождения и модификации
    - Более ясное отображение реального мира
- **Без ООП:** Код становится монолитным, сложным для понимания и изменения.

## Суть концепта

- Программа состоит из объектов, которые взаимодействуют друг с другом
- Каждый объект - экземпляр класса
- Класс - это шаблон для создания объектов
- **Аналогия:** Строительство дома из готовых блоков (объектов) вместо лепки из глины (процедурный подход)

## Основные принципы

### 1. [[Наследование]]

- Создание новых классов на основе существующих
- Ключевое слово `extends`

### 2. [[Инкапсуляция]]

- Сокрытие внутреннего состояния объекта
- Управление доступом через модификаторы `private`, `protected`, `public`

### 3. [[Полиморфизм]]

- Возможность объектов с одинаковой спецификацией иметь различную реализацию
- Переопределение и перегрузка методов

### 4. [[Абстракция]]

- Сокрытие сложной реализации и показ только существенных характеристик
- Абстрактные классы и интерфейсы

## Пример кода

``` Java
// Абстракция
abstract class Vehicle {
    protected String model;
    protected int speed;
    
    // Инкапсуляция
    private String vin; // скрытый внутренний идентификатор
    
    public Vehicle(String model, String vin) {
        this.model = model;
        this.vin = vin;
        this.speed = 0;
    }
    
    // Геттер для доступа к приватному полю
    public String getVin() { return vin; }
    
    // Абстрактный метод - должен быть реализован в наследниках
    public abstract void move();
    
    // Общий метод для всех транспортных средств
    public void stop() {
        this.speed = 0;
        System.out.println(model + " остановился");
    }
}

// Наследование
class Car extends Vehicle {
    private int doors;
    
    public Car(String model, String vin, int doors) {
        super(model, vin); // вызов конструктора родителя
        this.doors = doors;
    }
    
    // Полиморфизм - переопределение метода
    @Override
    public void move() {
        this.speed = 60;
        System.out.println(model + " едет по дороге со скоростью " + speed + " км/ч");
    }
    
    // Уникальный метод автомобиля
    public void openTrunk() {
        System.out.println("Багажник открыт");
    }
}

class Airplane extends Vehicle {
    private int altitude;
    
    public Airplane(String model, String vin) {
        super(model, vin);
        this.altitude = 0;
    }
    
    // Полиморфизм - другое поведение для самолета
    @Override
    public void move() {
        this.speed = 800;
        this.altitude = 10000;
        System.out.println(model + " летит на высоте " + altitude + " метров");
    }
    
    // Уникальный метод самолета
    public void takeOff() {
        System.out.println(model + " взлетает");
    }
}

public class Main {
    public static void main(String[] args) {
        // Полиморфизм: работа с разными объектами через один тип
        Vehicle[] vehicles = {
            new Car("Toyota Camry", "VIN123", 4),
            new Airplane("Boeing 737", "VIN456")
        };
        
        // Одинаковый интерфейс - разное поведение
        for (Vehicle vehicle : vehicles) {
            vehicle.move(); // Полиморфный вызов
            vehicle.stop();
            System.out.println("VIN: " + vehicle.getVin()); // Инкапсуляция
            System.out.println("---");
        }
        
        // Работа с конкретным типом
        Car car = new Car("Honda Civic", "VIN789", 2);
        car.move();
        car.openTrunk(); // Уникальный метод автомобиля
    }
}
```

## Связи

- **Включает в себя:**
    - [[Наследование]]
    - [[Инкапсуляция]]
    - [[Полиморфизм]]
    - [[Абстракция]]
- **Основано на:**
    - [[Классы и объекты|Классах и объектах]]
    - [[Конструкторы|Конструкторах]]
    - [[Модификаторы доступа|Модификаторах доступа]]
- **Связанные концепты:**
    - Принципы [[SOLID]] (развитие идей [[ООП]])
    - Шаблоны проектирования
    - Архитектура приложений