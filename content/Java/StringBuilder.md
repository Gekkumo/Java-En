---
---
StringBuilder (и его потокобезопасная версия [[StringBuffer]] - это классы в Java, предназначенные для эффективного построения строк, особенно при множественных операциях конкатенации. В отличие от обычных строк (String), которые иммутабельны (неизменяемы), StringBuilder использует изменяемый буфер символов, что позволяет избежать создания множества временных объектов.
## Внутреннее представление

`StringBuilder` внутри хранит символы в **массиве `char[]`** (до Java 9) или **`byte[]`** (в Java 9+ с оптимизацией для Latin-1 и UTF-16).
### Поля класса (упрощённо)**:

public final class StringBuilder extends AbstractStringBuilder {
    char[] value;  // массив символов (в Java 9+ может быть byte[])
    int count;     // текущее количество символов
}

(На самом деле, `StringBuilder` наследуется от `AbstractStringBuilder`, где и хранятся основные поля и методы.)
## Динамическое расширение буфера

При добавлении новых символов (`append()`, `insert()` и т. д.) `StringBuilder` проверяет, хватает ли места в массиве. Если нет — **увеличивает его размер** по формуле:

newCapacity = (oldCapacity * 2) + 2

(Например, если начальный размер 16, то после переполнения он станет 34, затем 70 и т. д.)

Это позволяет минимизировать копирования при частых добавлениях.
## Пример работы `append()`

Рассмотрим код:

StringBuilder sb = new StringBuilder();  // начальная ёмкость = 16
sb.append("Hello");
sb.append(" ");
sb.append("World");

1. При создании `StringBuilder` выделяется массив `char[16]`.
    
2. При `append("Hello")` символы копируются в массив (`count = 5`).
    
3. При `append(" ")` добавляется пробел (`count = 6`).
    
4. При `append("World")` проверяется, хватает ли места (нужно ещё 5 символов, всего 11). Поскольку 11 < 16, символы добавляются без расширения.
    
5. Если бы места не хватило, массив пересоздался бы с новым размером (`34`).
## Преобразование в строку (`toString()`)

Когда вызывается `toString()`, создаётся **новая строка** на основе текущего содержимого буфера:

@Override
public String toString() {
    return new String(value, 0, count);  // копирует только заполненную часть
}

Это значит, что последующее изменение `StringBuilder` не повлияет на уже полученную строку.
## Разница между `StringBuilder` и `StringBuffer`

|**Критерий**|**StringBuilder**|**StringBuffer**|
|---|---|---|
|**Потокобезопасность**|Нет (быстрее)|Да (медленнее)|
|**Синхронизация**|Не синхронизирован|Синхронизированные методы|
|**Производительность**|Выше|Ниже из-за блокировок|
|**С версии Java**|1.5|1.0|

## Оптимизации в Java 9+

В Java 9 `StringBuilder` (как и `String`) использует **`byte[]` вместо `char[]`** для экономии памяти:

- Если строка содержит только **Latin-1** (1 байт на символ), используется `byte[]`.
    
- Если есть символы **UTF-16** (2 байта на символ), переключается на `char[]`-подобное хранение.

Это уменьшает расход памяти для строк, состоящих из ASCII-символов.
## Вывод:

- `StringBuilder` внутри использует **массив символов (`char[]` или `byte[]`)**.
    
- При переполнении массив **расширяется в ~2 раза** (аналогично `ArrayList`).
    
- `append()` работает за **O(1)** (амортизированно), но при расширении — **O(n)**.
    
- `StringBuffer` работает так же, но с синхронизацией (медленнее).
    
- В Java 9+ используется **`byte[]`** для оптимизации памяти.

**Оптимальное использование:**

StringBuilder sb = new StringBuilder(128);  // задаём начальный размер, если знаем длину
sb.append("Hello").append(" ").append("World");  // method chaining
String result = sb.toString();